/**
 * Avatar System - æ•´åˆæ‰€æœ‰æ¨¡å—çš„æ ¸å¿ƒç³»ç»Ÿ
 * 
 * å°† OpenClaw è¿æ¥ã€æƒ…ç»ªæ£€æµ‹ã€TTSã€å£å‹åŒæ­¥ç»Ÿä¸€ç®¡ç†
 * 
 * v5.0 - SOTA Round 42: æµå¼ TTS
 * - Viseme ç²¾ç¡®å£å‹
 * - å¾®è¡¨æƒ…ç³»ç»Ÿ
 * - è¡¨æƒ…åºåˆ—åŠ¨ç”» (å¤åˆè¡¨æƒ…ã€æƒ…ç»ªæƒ¯æ€§)
 * - æƒ…ç»ªä¸Šä¸‹æ–‡å¼•æ“ (å¯¹è¯åŸºè°ƒã€è¯é¢˜è¯†åˆ«ã€æƒ…ç»ªæƒ¯æ€§)
 * - âœ¨ æµå¼ TTS (å¥å­çº§åˆ†å‰²ã€è¾¹åˆæˆè¾¹æ’­æ”¾ã€ä½é¦–å­—å»¶è¿Ÿ)
 */

import { avatarController, type Expression } from './AvatarController';
import { OpenClawConnector, type ConnectionStatus, type MessageChunk } from './OpenClawConnector';
import { OpenClawBridgeConnector } from './OpenClawBridgeConnector';
import { detectEmotion, getEmotionDuration } from './EmotionDetector';
import { TTSService, createTTSService, type TTSResult } from './TTSService';
import { StreamingTTSManager, createStreamingTTSManager, type StreamingTTSState } from './StreamingTTSManager';
import { LipSyncDriver } from './LipSyncDriver';
import { visemeDriver } from './VisemeDriver';
import { microExpressionSystem } from './MicroExpressionSystem';
import { expressionSequencer, analyzeTextForSequence } from './ExpressionSequencer';
import { emotionContextEngine, type ConversationTone } from './EmotionContextEngine';
import { headTrackingService, type TrackingData } from './HeadTrackingService';
import { keyboardShortcuts, formatShortcut } from './KeyboardShortcuts';
import { gestureRecognitionService, type GestureResult } from './GestureRecognitionService';
import { gestureReactionMapper, type GestureReaction } from './GestureReactionMapper';
import { expressionVariantSystem, type VariantContext, type VariantSelection } from './ExpressionVariantSystem';
import { 
  sceneDirector, 
  type SceneMode, 
  type SceneState, 
  type SceneElements,
  type SceneChangeEvent 
} from './SceneDirectorSystem';
import {
  AvatarTouchInteraction,
  createAvatarTouchInteraction,
  mapHitAreaToTouchArea,
  type TouchArea,
  type TouchType,
  type InteractionReaction,
  type EmotionalState as TouchEmotionalState,
  type InteractionStats,
  type AvatarTouchConfig,
} from './AvatarTouchInteraction';

export interface AvatarSystemConfig {
  gatewayUrl?: string;
  gatewayToken?: string;
  fishApiKey?: string;
  bridgeUrl?: string;       // OpenClaw Bridge URL
  useBridge?: boolean;      // ä½¿ç”¨ Bridge æ¨¡å¼
  enableTTS?: boolean;
  enableLipSync?: boolean;
  enableEmotionDetection?: boolean;
  /** å¯ç”¨æµå¼ TTS (è¾¹åˆæˆè¾¹æ’­æ”¾ï¼Œé™ä½é¦–å­—å»¶è¿Ÿ) */
  useStreamingTTS?: boolean;
}

export interface SystemState {
  connectionStatus: ConnectionStatus;
  isSpeaking: boolean;
  currentEmotion: Expression;
  lastMessage: string;
  processingText: string;
  isHeadTrackingActive: boolean;
  headTrackingSupported: boolean;
  isGestureRecognitionActive: boolean;
  lastGesture: string | null;
  lastGestureMessage: string | null;
}

type StateChangeCallback = (state: SystemState) => void;
type TextCallback = (text: string, isComplete: boolean) => void;

export class AvatarSystem {
  private connector: OpenClawConnector;
  private bridgeConnector: OpenClawBridgeConnector;
  private useBridge: boolean = true;  // é»˜è®¤ä½¿ç”¨ Bridge
  private ttsService: TTSService | null = null;
  private streamingTTSManager: StreamingTTSManager | null = null;
  private lipSyncDriver: LipSyncDriver;
  private config: Required<AvatarSystemConfig>;
  
  private stateCallbacks: Set<StateChangeCallback> = new Set();
  private textCallbacks: Set<TextCallback> = new Set();
  
  private state: SystemState = {
    connectionStatus: 'disconnected',
    isSpeaking: false,
    currentEmotion: 'neutral',
    lastMessage: '',
    processingText: '',
    isHeadTrackingActive: false,
    headTrackingSupported: false,
    isGestureRecognitionActive: false,
    lastGesture: null,
    lastGestureMessage: null,
  };
  
  // å¤´éƒ¨è¿½è¸ªå–æ¶ˆè®¢é˜…å‡½æ•°
  private headTrackingUnsubscribe: (() => void) | null = null;

  // æ‰‹åŠ¿è¯†åˆ«å–æ¶ˆè®¢é˜…å‡½æ•°
  private gestureRecognitionUnsubscribe: (() => void) | null = null;
  private gestureReactionUnsubscribe: (() => void) | null = null;

  // è§¦æ‘¸äº’åŠ¨ç³»ç»Ÿ
  private touchInteraction: AvatarTouchInteraction;
  private touchReactionUnsubscribe: (() => void) | null = null;
  private touchAffectionUnsubscribe: (() => void) | null = null;
  private touchExcessiveUnsubscribe: (() => void) | null = null;

  // æƒ…ç»ªæ¢å¤å®šæ—¶å™¨
  private emotionResetTimer: ReturnType<typeof setTimeout> | null = null;
  
  // TTS é˜Ÿåˆ—
  private ttsQueue: string[] = [];
  private isProcessingTTS = false;

  constructor(config: AvatarSystemConfig = {}) {
    // æ£€æµ‹è¿è¡Œç¯å¢ƒ
    const hostname = typeof window !== 'undefined' ? window.location.hostname : 'localhost';
    const isLocal = hostname === 'localhost' || 
                    hostname === '127.0.0.1' || 
                    hostname.startsWith('192.168.') ||
                    hostname.startsWith('10.') ||
                    hostname.endsWith('.local');
    const origin = typeof window !== 'undefined' ? window.location.origin : '';
    
    // æ ¹æ®ç¯å¢ƒé€‰æ‹©é»˜è®¤ URL
    const defaultGatewayUrl = isLocal 
      ? 'ws://localhost:18789/ws'
      : `${origin.replace('http', 'ws')}/api/gateway/ws`;
    const defaultBridgeUrl = isLocal 
      ? 'http://localhost:12394'
      : `${origin}/api/bridge`;
    
    console.log(`[AvatarSystem] ç¯å¢ƒæ£€æµ‹: ${isLocal ? 'æœ¬åœ°' : 'å¤–ç½‘'}`);
    console.log(`[AvatarSystem] Gateway URL: ${config.gatewayUrl ?? defaultGatewayUrl}`);
    console.log(`[AvatarSystem] Bridge URL: ${config.bridgeUrl ?? defaultBridgeUrl}`);
    
    this.config = {
      gatewayUrl: config.gatewayUrl ?? defaultGatewayUrl,
      gatewayToken: config.gatewayToken ?? '',
      fishApiKey: config.fishApiKey ?? '',
      bridgeUrl: config.bridgeUrl ?? defaultBridgeUrl,
      useBridge: config.useBridge ?? true,
      enableTTS: config.enableTTS ?? true,
      enableLipSync: config.enableLipSync ?? true,
      enableEmotionDetection: config.enableEmotionDetection ?? true,
      useStreamingTTS: config.useStreamingTTS ?? false,  // æµå¼ TTS æœ‰ bugï¼Œé»˜è®¤ç¦ç”¨
    };

    this.useBridge = this.config.useBridge ?? true;

    // åˆå§‹åŒ– WebSocket è¿æ¥å™¨
    this.connector = new OpenClawConnector({
      gatewayUrl: this.config.gatewayUrl,
      token: this.config.gatewayToken,
    });

    // åˆå§‹åŒ– Bridge è¿æ¥å™¨ (æ›´ç¨³å®š)
    this.bridgeConnector = new OpenClawBridgeConnector({
      bridgeUrl: this.config.bridgeUrl,
    });

    // åˆå§‹åŒ–å£å‹åŒæ­¥
    this.lipSyncDriver = new LipSyncDriver({
      smoothing: 0.4,
      sensitivity: 1.2,
    });

    // åˆå§‹åŒ–è§¦æ‘¸äº’åŠ¨ç³»ç»Ÿ
    this.touchInteraction = createAvatarTouchInteraction({
      enabled: true,
      hapticFeedback: true,
      soundEnabled: true,
      particleEnabled: true,
    });
    this.setupTouchInteractionCallbacks();

    // åˆå§‹åŒ– TTS
    if (this.config.enableTTS) {
      this.ttsService = createTTSService(this.config.fishApiKey);
      
      // åˆå§‹åŒ–æµå¼ TTS (æ˜¾è‘—é™ä½é¦–å­—å»¶è¿Ÿ)
      if (this.config.useStreamingTTS) {
        this.streamingTTSManager = createStreamingTTSManager({
          apiKey: this.config.fishApiKey || 'ceea7f5420dc4214807f4ce5dccb9da3',
          referenceId: '9dec9671824543b4a4f9f382dbf15748',
          minSegmentLength: 8,
          maxSegmentLength: 80,
          prefetchCount: 2,
          segmentGap: 100,
        });
        this.setupStreamingTTSCallbacks();
        console.log('[AvatarSystem] æµå¼ TTS å·²å¯ç”¨ - é¦–å­—å»¶è¿Ÿå°†å¤§å¹…é™ä½');
      }
    }

    // è®¾ç½®äº‹ä»¶å¤„ç†
    this.setupEventHandlers();
  }
  
  /**
   * è®¾ç½®æµå¼ TTS å›è°ƒ
   */
  private setupStreamingTTSCallbacks(): void {
    if (!this.streamingTTSManager) return;
    
    this.streamingTTSManager.setCallbacks({
      onStateChange: (state: StreamingTTSState) => {
        // æ›´æ–°è¯´è¯çŠ¶æ€
        const isSpeaking = state.status === 'playing' || state.status === 'synthesizing';
        if (this.state.isSpeaking !== isSpeaking) {
          this.updateState({ isSpeaking });
        }
        
        // æ‰“å°é¦–å­—å»¶è¿Ÿä¿¡æ¯
        if (state.firstTokenLatency !== null && state.currentSegment === 0 && state.status === 'playing') {
          console.log(`[AvatarSystem] ğŸš€ æµå¼ TTS é¦–å­—å»¶è¿Ÿ: ${state.firstTokenLatency.toFixed(0)}ms`);
        }
      },
      
      onSegmentStart: (index: number, text: string) => {
        console.log(`[AvatarSystem] æ’­æ”¾ç‰‡æ®µ ${index}: "${text.slice(0, 30)}..."`);
        
        // æ£€æµ‹ç‰‡æ®µæƒ…ç»ªå¹¶åº”ç”¨è¡¨æƒ…
        if (this.config.enableEmotionDetection) {
          const emotion = detectEmotion(text);
          if (emotion && emotion.emotion !== 'neutral' && emotion.confidence > 0.3) {
            this.setEmotion(emotion.emotion as Expression);
          }
        }
      },
      
      onAudioAvailable: (audio: HTMLAudioElement, segmentIndex: number) => {
        // è¿æ¥å£å‹åŒæ­¥
        if (this.config.enableLipSync) {
          // ä½¿ç”¨ç®€å•å£å‹åŒæ­¥ (VisemeDriver ä¸æ”¯æŒç›´æ¥è¿æ¥éŸ³é¢‘)
          this.lipSyncDriver.connect(audio).then(() => {
            this.lipSyncDriver.start();
          }).catch(err => {
            console.warn('[AvatarSystem] å£å‹åŒæ­¥è¿æ¥å¤±è´¥:', err);
          });
        }
      },
      
      onSegmentEnd: (index: number) => {
        // ç‰‡æ®µæ’­æ”¾å®Œæˆ
      },
      
      onComplete: () => {
        console.log('[AvatarSystem] æµå¼ TTS æ’­æ”¾å®Œæˆ');
        this.updateState({ isSpeaking: false });
        avatarController.setMouthOpenY(0);
      },
      
      onError: (error: Error, segment: number) => {
        console.error(`[AvatarSystem] æµå¼ TTS ç‰‡æ®µ ${segment} é”™è¯¯:`, error);
      },
    });
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†å™¨
   */
  private setupEventHandlers() {
    // è¿æ¥çŠ¶æ€å˜åŒ–
    this.connector.onStatusChange((status) => {
      this.updateState({ connectionStatus: status });
    });

    // æ¶ˆæ¯æ¥æ”¶
    this.connector.onMessage((chunk) => {
      this.handleMessageChunk(chunk);
    });

    // å£å‹åŒæ­¥æ›´æ–° (fallback ç”¨)
    this.lipSyncDriver.onMouthUpdate((openY) => {
      // å¦‚æœ Viseme æ²¡æœ‰å¯ç”¨ï¼Œä½¿ç”¨ç®€å•å£å‹åŒæ­¥
      if (!this.useViseme) {
        avatarController.setMouthOpenY(openY);
      }
    });

    // åˆå§‹åŒ–é«˜çº§ç³»ç»Ÿ (Viseme + å¾®è¡¨æƒ…)
    avatarController.initAdvancedSystems();
    
    console.log('[AvatarSystem] é«˜çº§åŠ¨ç”»ç³»ç»Ÿå·²å¯åŠ¨');
  }

  /**
   * è®¾ç½®è§¦æ‘¸äº’åŠ¨å›è°ƒ
   */
  private setupTouchInteractionCallbacks(): void {
    // è§¦æ‘¸ååº”å›è°ƒ - åº”ç”¨è¡¨æƒ…å’ŒåŠ¨ä½œ
    this.touchReactionUnsubscribe = this.touchInteraction.onReaction((reaction, event) => {
      console.log(`[AvatarSystem] è§¦æ‘¸ååº”: ${event.area} ${event.type}`);
      
      // åº”ç”¨è¡¨æƒ…
      if (reaction.expression) {
        this.setEmotion(reaction.expression as Expression);
      }
      
      // æ’­æ”¾åŠ¨ä½œ
      if (reaction.motion) {
        avatarController.playMotion(reaction.motion);
      }
      
      // æ’­æ”¾å¯¹è¯ TTS
      if (reaction.dialogue && this.config.enableTTS) {
        this.speak(reaction.dialogue);
      }
      
      // è§¦å‘ç²’å­æ•ˆæœ (é€šè¿‡äº‹ä»¶é€šçŸ¥ UI)
      if (reaction.particle) {
        this.notifyTouchParticle(reaction.particle);
      }
    });

    // äº²å¯†åº¦å˜åŒ–å›è°ƒ
    this.touchAffectionUnsubscribe = this.touchInteraction.onAffectionChange((affection, delta) => {
      console.log(`[AvatarSystem] äº²å¯†åº¦: ${affection.toFixed(1)} (${delta >= 0 ? '+' : ''}${delta.toFixed(1)})`);
    });

    // è¿‡åº¦è§¦æ‘¸å›è°ƒ
    this.touchExcessiveUnsubscribe = this.touchInteraction.onExcessiveTouch((area, message) => {
      console.log(`[AvatarSystem] è¿‡åº¦è§¦æ‘¸ ${area}: ${message}`);
      
      // æ’­æ”¾æŠ±æ€¨è¯­éŸ³
      if (this.config.enableTTS) {
        this.speak(message);
      }
      
      // æ˜¾ç¤ºçƒ¦èºè¡¨æƒ…
      this.setEmotion('annoyed');
    });

    // å¯åŠ¨è§¦æ‘¸ç³»ç»Ÿ
    this.touchInteraction.start();
    console.log('[AvatarSystem] è§¦æ‘¸äº’åŠ¨ç³»ç»Ÿå·²å¯åŠ¨');
  }

  // è§¦æ‘¸ç²’å­å›è°ƒ
  private touchParticleCallbacks: Set<(particle: string) => void> = new Set();

  /**
   * è®¢é˜…è§¦æ‘¸ç²’å­æ•ˆæœäº‹ä»¶
   */
  onTouchParticle(callback: (particle: string) => void): () => void {
    this.touchParticleCallbacks.add(callback);
    return () => this.touchParticleCallbacks.delete(callback);
  }

  private notifyTouchParticle(particle: string): void {
    for (const callback of this.touchParticleCallbacks) {
      try {
        callback(particle);
      } catch (e) {
        console.error('[AvatarSystem] è§¦æ‘¸ç²’å­å›è°ƒé”™è¯¯:', e);
      }
    }
  }

  // ============== è§¦æ‘¸äº’åŠ¨ API ==============

  /**
   * å¤„ç† Live2D hit area è§¦æ‘¸å¼€å§‹
   */
  handleTouchStart(hitArea: string, position: { x: number; y: number }): void {
    const area = mapHitAreaToTouchArea(hitArea);
    this.touchInteraction.handleTouchStart(area, position);
  }

  /**
   * å¤„ç† Live2D hit area è§¦æ‘¸ç»“æŸ
   */
  handleTouchEnd(hitArea: string, position: { x: number; y: number }): void {
    const area = mapHitAreaToTouchArea(hitArea);
    this.touchInteraction.handleTouchEnd(area, position);
  }

  /**
   * å¤„ç†è§¦æ‘¸ç§»åŠ¨
   */
  handleTouchMove(hitArea: string, position: { x: number; y: number }, delta: { x: number; y: number }): void {
    const area = mapHitAreaToTouchArea(hitArea);
    this.touchInteraction.handleTouchMove(area, position, delta);
  }

  /**
   * å¿«æ·æ–¹æ³• - æ‘¸å¤´
   */
  patHead(): void {
    this.touchInteraction.pat('head');
  }

  /**
   * å¿«æ·æ–¹æ³• - æˆ³è„¸
   */
  pokeCheek(): void {
    this.touchInteraction.poke('cheek');
  }

  /**
   * å¿«æ·æ–¹æ³• - æ‹è‚©
   */
  patShoulder(): void {
    this.touchInteraction.pat('shoulder');
  }

  /**
   * è·å–äº²å¯†åº¦
   */
  getAffection(): number {
    return this.touchInteraction.getAffection();
  }

  /**
   * è®¾ç½®äº²å¯†åº¦
   */
  setAffection(value: number): void {
    this.touchInteraction.setAffection(value);
  }

  /**
   * è·å–è§¦æ‘¸æƒ…æ„ŸçŠ¶æ€
   */
  getTouchEmotionalState(): TouchEmotionalState {
    return this.touchInteraction.getEmotionalState();
  }

  /**
   * è·å–è§¦æ‘¸ç»Ÿè®¡
   */
  getTouchStats(): InteractionStats {
    return this.touchInteraction.getStats();
  }

  /**
   * é…ç½®è§¦æ‘¸äº’åŠ¨
   */
  configureTouchInteraction(config: Partial<AvatarTouchConfig>): void {
    this.touchInteraction.updateConfig(config);
  }

  /**
   * å¯¼å‡ºè§¦æ‘¸äº’åŠ¨æ•°æ®
   */
  exportTouchData(): { affection: number; stats: InteractionStats } {
    return this.touchInteraction.exportData();
  }

  /**
   * å¯¼å…¥è§¦æ‘¸äº’åŠ¨æ•°æ®
   */
  importTouchData(data: { affection?: number; stats?: Partial<InteractionStats> }): void {
    this.touchInteraction.importData(data);
  }

  // æ˜¯å¦ä½¿ç”¨ Viseme ç²¾ç¡®å£å‹ (é»˜è®¤å¯ç”¨)
  private useViseme = true;

  /**
   * å¯ç”¨/ç¦ç”¨ Viseme ç²¾ç¡®å£å‹
   */
  setUseViseme(enabled: boolean) {
    this.useViseme = enabled;
    avatarController.setVisemeEnabled(enabled);
    console.log('[AvatarSystem] Viseme å£å‹:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  /**
   * å¯ç”¨/ç¦ç”¨å¾®è¡¨æƒ…ç³»ç»Ÿ
   */
  setUseMicroExpression(enabled: boolean) {
    avatarController.setMicroExpressionEnabled(enabled);
    console.log('[AvatarSystem] å¾®è¡¨æƒ…:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  // æµå¼ TTS æ˜¯å¦å·²å¼€å§‹
  private isStreamingTTSStarted = false;

  /**
   * å¤„ç†æ¶ˆæ¯ç‰‡æ®µ
   */
  private handleMessageChunk(chunk: MessageChunk) {
    if (chunk.type === 'text') {
      // ç´¯ç§¯æ–‡æœ¬
      this.updateState({
        processingText: this.state.processingText + chunk.content,
      });

      // é€šçŸ¥æ–‡æœ¬å›è°ƒ
      this.notifyTextCallbacks(chunk.content, false);

      // å®æ—¶æƒ…ç»ªæ£€æµ‹
      if (this.config.enableEmotionDetection) {
        this.detectAndApplyEmotion(chunk.content);
      }

      // æµå¼ TTS å¤„ç† (è¾¹æ¥æ”¶è¾¹åˆæˆï¼Œæ˜¾è‘—é™ä½é¦–å­—å»¶è¿Ÿ)
      if (this.config.enableTTS && this.config.useStreamingTTS && this.streamingTTSManager) {
        // ç¬¬ä¸€ä¸ªæ–‡æœ¬å—ï¼Œå¯åŠ¨æµå¼æ¨¡å¼
        if (!this.isStreamingTTSStarted) {
          this.streamingTTSManager.startStream();
          this.isStreamingTTSStarted = true;
          console.log('[AvatarSystem] ğŸš€ å¼€å§‹æµå¼ TTS');
        }
        // è¿½åŠ æ–‡æœ¬åˆ°æµå¼ TTS
        this.streamingTTSManager.appendText(chunk.content);
      }
      // ä¼ ç»Ÿ TTS é˜Ÿåˆ—å¤„ç†
      else if (this.config.enableTTS && this.ttsService) {
        this.queueTTS(chunk.content);
      }
    } 
    else if (chunk.type === 'end') {
      // å®Œæ•´æ¶ˆæ¯
      const fullText = chunk.content;
      this.updateState({
        lastMessage: fullText,
        processingText: '',
      });

      // é€šçŸ¥å®Œæˆ
      this.notifyTextCallbacks(fullText, true);

      // ç»“æŸæµå¼ TTS
      if (this.isStreamingTTSStarted && this.streamingTTSManager) {
        this.streamingTTSManager.endStream();
        this.isStreamingTTSStarted = false;
        console.log('[AvatarSystem] âœ… æµå¼ TTS ç»“æŸ');
      }

      console.log('[AvatarSystem] æ¶ˆæ¯å®Œæˆ:', fullText.slice(0, 100));
    }
    else if (chunk.type === 'error') {
      console.error('[AvatarSystem] æ¶ˆæ¯é”™è¯¯:', chunk.content);
      this.setEmotion('sad');
      
      // é”™è¯¯æ—¶ä¹Ÿè¦ç»“æŸæµå¼ TTS
      if (this.isStreamingTTSStarted && this.streamingTTSManager) {
        this.streamingTTSManager.stop();
        this.isStreamingTTSStarted = false;
      }
    }
    else if ((chunk as any).type === 'thinking') {
      // æ€è€ƒæ—¶å¯ä»¥æ˜¾ç¤ºä¸€ä¸ª "æ€è€ƒä¸­" çš„çŠ¶æ€
      console.log('[AvatarSystem] ğŸ¤” æ€è€ƒä¸­...');
      // æ€è€ƒæ—¶ä¿æŒå½“å‰è¡¨æƒ…æˆ–æ˜¾ç¤ºä¸­æ€§
    }
    else if ((chunk as any).type === 'tool') {
      console.log('[AvatarSystem] ğŸ”§ å·¥å…·è°ƒç”¨');
      // å·¥å…·è°ƒç”¨æ—¶å¯ä»¥æ˜¾ç¤ºä¸€ä¸ªå¿™ç¢Œçš„è¡¨æƒ…
    }
  }

  // æ˜¯å¦ä½¿ç”¨æƒ…ç»ªä¸Šä¸‹æ–‡å¼•æ“ (é»˜è®¤å¯ç”¨)
  private useContextEngine = true;

  /**
   * å¯ç”¨/ç¦ç”¨æƒ…ç»ªä¸Šä¸‹æ–‡å¼•æ“
   */
  setUseContextEngine(enabled: boolean) {
    this.useContextEngine = enabled;
    console.log('[AvatarSystem] æƒ…ç»ªä¸Šä¸‹æ–‡å¼•æ“:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  /**
   * è·å–å¯¹è¯åŸºè°ƒ
   */
  getConversationTone(): ConversationTone {
    return emotionContextEngine.getConversationTone();
  }

  /**
   * è·å–æƒ…ç»ªè¶‹åŠ¿åˆ†æ
   */
  getEmotionTrend() {
    return emotionContextEngine.analyzeEmotionTrend();
  }

  /**
   * è·å–æƒ…ç»ªä¸Šä¸‹æ–‡è°ƒè¯•ä¿¡æ¯
   */
  getEmotionContextDebug(): string {
    return emotionContextEngine.getDebugSummary();
  }

  /**
   * é‡ç½®æƒ…ç»ªä¸Šä¸‹æ–‡
   */
  resetEmotionContext() {
    emotionContextEngine.reset();
    console.log('[AvatarSystem] æƒ…ç»ªä¸Šä¸‹æ–‡å·²é‡ç½®');
  }

  /**
   * æ£€æµ‹å¹¶åº”ç”¨æƒ…ç»ª (v4.0 - å¸¦ä¸Šä¸‹æ–‡æ„ŸçŸ¥)
   */
  private detectAndApplyEmotion(text: string) {
    // é¦–å…ˆå°è¯•åŒ¹é…è¡¨æƒ…åºåˆ—ï¼ˆæ›´ä¸°å¯Œçš„è¡¨æƒ…ååº”ï¼‰
    if (this.useSequencer && analyzeTextForSequence(text)) {
      console.log('[AvatarSystem] è§¦å‘è¡¨æƒ…åºåˆ—');
      return;
    }
    
    // åŸºç¡€æƒ…ç»ªæ£€æµ‹
    const result = detectEmotion(text);
    
    let finalEmotion = result.emotion;
    let finalIntensity = result.confidence;
    
    // ä½¿ç”¨ä¸Šä¸‹æ–‡å¼•æ“å¢å¼ºæƒ…ç»ªæ£€æµ‹
    if (this.useContextEngine) {
      const contextResult = emotionContextEngine.processText(
        text,
        result.emotion,
        result.confidence
      );
      
      finalEmotion = contextResult.emotion;
      finalIntensity = contextResult.intensity;
      
      // è®°å½•ä¸Šä¸‹æ–‡å½±å“
      if (contextResult.influences.length > 1) {
        const sources = contextResult.influences.map(i => `${i.source}:${i.emotion}`).join(', ');
        console.log('[AvatarSystem] æƒ…ç»ªä¸Šä¸‹æ–‡:', sources, 'â†’', finalEmotion);
      }
      
      // SOTA Round 40: åœºæ™¯å¯¼æ¼”è‡ªåŠ¨åˆ†æ
      if (this.useSceneDirector) {
        const tone = emotionContextEngine.getConversationTone();
        sceneDirector.analyzeText(text, finalEmotion, tone.atmosphere);
      }
    }
    
    // åªæœ‰ç½®ä¿¡åº¦è¶³å¤Ÿé«˜æ‰åˆ‡æ¢è¡¨æƒ…
    if (finalIntensity > 0.3 && finalEmotion !== 'neutral') {
      let expressionToApply: Expression = finalEmotion;
      
      // SOTA Round 26: ä½¿ç”¨è¡¨æƒ…å˜ä½“ç³»ç»Ÿé€‰æ‹©æ›´ä¸°å¯Œçš„è¡¨æƒ…
      if (this.useVariantSystem) {
        // æ ¹æ®æ–‡æœ¬æ¨æ–­ä¸Šä¸‹æ–‡
        const inferredContext = expressionVariantSystem.inferContextFromText(text);
        expressionVariantSystem.setContext(inferredContext);
        
        // é€‰æ‹©è¡¨æƒ…å˜ä½“
        const variantSelection = expressionVariantSystem.selectVariant(
          finalEmotion as any, // emotion è½¬æ¢
          finalIntensity,
          inferredContext
        );
        
        expressionToApply = variantSelection.expression;
        console.log('[AvatarSystem] å˜ä½“é€‰æ‹©:', 
          `${finalEmotion} â†’ ${expressionToApply}`,
          `(${inferredContext}, ${variantSelection.reason})`
        );
      }
      
      // ä½¿ç”¨æ™ºèƒ½è¡¨æƒ…åˆ‡æ¢ï¼ˆå¸¦æƒ¯æ€§ï¼‰
      if (this.useSequencer) {
        expressionSequencer.setEmotionSmart(expressionToApply);
      } else {
        this.setEmotion(expressionToApply);
      }
      
      // è®¾ç½®è‡ªåŠ¨æ¢å¤ - åŸºäºä¸Šä¸‹æ–‡è°ƒæ•´æŒç»­æ—¶é—´
      const baseDuration = getEmotionDuration(result);
      const tone = emotionContextEngine.getConversationTone();
      // å¦‚æœå¯¹è¯åŸºè°ƒå’Œå½“å‰æƒ…ç»ªä¸€è‡´ï¼Œå»¶é•¿æŒç»­æ—¶é—´
      const durationMultiplier = tone.baseEmotion === finalEmotion ? 1.5 : 1.0;
      this.scheduleEmotionReset(baseDuration * durationMultiplier);
    }
  }
  
  // æ˜¯å¦ä½¿ç”¨è¡¨æƒ…åºåˆ—ç³»ç»Ÿ (é»˜è®¤å¯ç”¨)
  private useSequencer = true;
  
  // æ˜¯å¦ä½¿ç”¨è¡¨æƒ…å˜ä½“ç³»ç»Ÿ (é»˜è®¤å¯ç”¨) - SOTA Round 26
  private useVariantSystem = true;
  
  // æ˜¯å¦ä½¿ç”¨åœºæ™¯å¯¼æ¼”ç³»ç»Ÿ (é»˜è®¤å¯ç”¨) - SOTA Round 40
  private useSceneDirector = true;

  /**
   * å¯ç”¨/ç¦ç”¨è¡¨æƒ…å˜ä½“ç³»ç»Ÿ
   */
  setUseVariantSystem(enabled: boolean) {
    this.useVariantSystem = enabled;
    console.log('[AvatarSystem] è¡¨æƒ…å˜ä½“ç³»ç»Ÿ:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  // ========== SOTA Round 40: åœºæ™¯å¯¼æ¼”ç³»ç»Ÿ API ==========

  /**
   * å¯ç”¨/ç¦ç”¨åœºæ™¯å¯¼æ¼”ç³»ç»Ÿ
   */
  setUseSceneDirector(enabled: boolean) {
    this.useSceneDirector = enabled;
    console.log('[AvatarSystem] åœºæ™¯å¯¼æ¼”ç³»ç»Ÿ:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  /**
   * æ‰‹åŠ¨åˆ‡æ¢åœºæ™¯
   */
  setScene(mode: SceneMode, immediate?: boolean) {
    sceneDirector.setScene(mode, { immediate });
    console.log('[AvatarSystem] åœºæ™¯åˆ‡æ¢:', mode);
  }

  /**
   * è·å–å½“å‰åœºæ™¯çŠ¶æ€
   */
  getSceneState(): SceneState {
    return sceneDirector.getState();
  }

  /**
   * è·å–å½“å‰åœºæ™¯å…ƒç´ é…ç½®
   */
  getSceneElements(): SceneElements {
    return sceneDirector.getCurrentElements();
  }

  /**
   * è®¾ç½®åœºæ™¯è‡ªåŠ¨æ£€æµ‹
   */
  setSceneAutoMode(enabled: boolean) {
    sceneDirector.setAutoMode(enabled);
    console.log('[AvatarSystem] åœºæ™¯è‡ªåŠ¨æ£€æµ‹:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  /**
   * è®¢é˜…åœºæ™¯å˜åŒ–
   */
  onSceneChange(callback: (event: SceneChangeEvent) => void): () => void {
    return sceneDirector.onSceneChange(callback);
  }

  /**
   * è·å–åœºæ™¯å»ºè®®
   */
  getSceneSuggestion(text: string) {
    const emotion = detectEmotion(text).emotion;
    return sceneDirector.getSuggestion(text, emotion);
  }

  /**
   * æ‰‹åŠ¨é€‰æ‹©è¡¨æƒ…å˜ä½“
   */
  selectExpressionVariant(emotion: string, intensity?: number, context?: VariantContext): VariantSelection {
    return expressionVariantSystem.selectVariant(emotion as any, intensity, context);
  }

  /**
   * è®¾ç½®è¡¨æƒ…å˜ä½“ä¸Šä¸‹æ–‡
   */
  setVariantContext(context: VariantContext): void {
    expressionVariantSystem.setContext(context);
  }

  /**
   * è·å–è¡¨æƒ…å˜ä½“ä½¿ç”¨ç»Ÿè®¡
   */
  getVariantStats() {
    return {
      usage: expressionVariantSystem.getUsageStats(),
      context: expressionVariantSystem.getContextStats(),
      history: expressionVariantSystem.getHistory(),
    };
  }

  /**
   * è®¾ç½®è¡¨æƒ…
   */
  setEmotion(emotion: Expression) {
    if (emotion !== this.state.currentEmotion) {
      avatarController.setExpression(emotion);
      // åŒæ­¥æƒ…ç»ªåˆ° Viseme å’Œå¾®è¡¨æƒ…ç³»ç»Ÿ
      avatarController.syncEmotionToSystems(emotion);
      this.updateState({ currentEmotion: emotion });
      console.log('[AvatarSystem] è¡¨æƒ…åˆ‡æ¢:', emotion);
    }
  }

  /**
   * å®šæ—¶æ¢å¤ neutral è¡¨æƒ…
   */
  private scheduleEmotionReset(delayMs: number) {
    if (this.emotionResetTimer) {
      clearTimeout(this.emotionResetTimer);
    }
    
    this.emotionResetTimer = setTimeout(() => {
      if (!this.state.isSpeaking) {
        this.setEmotion('neutral');
      }
      this.emotionResetTimer = null;
    }, delayMs);
  }

  /**
   * å°†æ–‡æœ¬åŠ å…¥ TTS é˜Ÿåˆ—
   */
  private queueTTS(text: string) {
    // æŒ‰å¥å­åˆ†å‰²
    const sentences = text.split(/(?<=[ã€‚ï¼ï¼Ÿ.!?])/g).filter(s => s.trim());
    
    for (const sentence of sentences) {
      if (sentence.trim().length > 0) {
        this.ttsQueue.push(sentence.trim());
      }
    }
    
    // å¼€å§‹å¤„ç†é˜Ÿåˆ—
    this.processTTSQueue();
  }

  /**
   * å¤„ç† TTS é˜Ÿåˆ—
   */
  private async processTTSQueue() {
    if (this.isProcessingTTS || !this.ttsService || this.ttsQueue.length === 0) {
      return;
    }

    this.isProcessingTTS = true;
    this.updateState({ isSpeaking: true });

    try {
      while (this.ttsQueue.length > 0) {
        const text = this.ttsQueue.shift()!;
        
        try {
          console.log('[AvatarSystem] TTS æ’­æ”¾:', text);
          
          // åˆæˆè¯­éŸ³
          const result = await this.ttsService.synthesize(text);
          
          // æ’­æ”¾å¹¶åŒæ­¥å£å‹ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰
          await Promise.race([
            this.speakWithLipSync(text, result),
            new Promise((_, reject) => setTimeout(() => reject(new Error('TTS æ’­æ”¾è¶…æ—¶')), 30000))
          ]);
        } catch (e) {
          console.error('[AvatarSystem] TTS é”™è¯¯:', e);
          
          // TTS å¤±è´¥æ—¶ä½¿ç”¨æ¨¡æ‹Ÿå£å‹ï¼ˆçŸ­æš‚æ˜¾ç¤ºè¯´è¯çŠ¶æ€ï¼‰
          if (this.config.enableLipSync) {
            try {
              await this.lipSyncDriver.simulateLipSync(text, Math.min(text.length * 150, 3000));
            } catch (lipSyncErr) {
              console.warn('[AvatarSystem] æ¨¡æ‹Ÿå£å‹å¤±è´¥:', lipSyncErr);
            }
          }
        }
      }
    } finally {
      // æ— è®ºå¦‚ä½•éƒ½è¦é‡ç½®çŠ¶æ€
      this.isProcessingTTS = false;
      this.updateState({ isSpeaking: false });
      this.lipSyncDriver.stop();
      
      // æ¢å¤ neutral è¡¨æƒ…
      this.setEmotion('neutral');
    }
  }

  /**
   * æ’­æ”¾è¯­éŸ³å¹¶åŒæ­¥å£å‹
   */
  private async speakWithLipSync(text: string, ttsResult: TTSResult): Promise<void> {
    const audio = new Audio(ttsResult.audioUrl);
    
    // ä¼°ç®—éŸ³é¢‘æ—¶é•¿ (ä¸­æ–‡çº¦ 5 å­—/ç§’)
    const estimatedDuration = Math.max(1000, text.length * 200);
    
    // æ ‡è®°å¼€å§‹è¯´è¯
    microExpressionSystem.setSpeaking(true);
    
    // ä½¿ç”¨ Viseme ç²¾ç¡®å£å‹
    if (this.useViseme && this.config.enableLipSync) {
      // ç”Ÿæˆ Viseme åºåˆ—å¹¶æ’­æ”¾
      avatarController.speakWithViseme(text, estimatedDuration);
      
      // åˆ†ææ–‡æœ¬è§¦å‘å¾®è¡¨æƒ…
      avatarController.analyzeTextForMicroExpression(text);
    }
    
    // åŒæ—¶è¿æ¥ä¼ ç»Ÿå£å‹åŒæ­¥ (ä½œä¸ºå¤‡ç”¨)
    if (this.config.enableLipSync && !this.useViseme) {
      try {
        await this.lipSyncDriver.connect(audio);
        this.lipSyncDriver.start();
      } catch (e) {
        console.warn('[AvatarSystem] å£å‹åŒæ­¥è¿æ¥å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿ:', e);
      }
    }

    return new Promise((resolve, reject) => {
      audio.onended = () => {
        this.lipSyncDriver.stop();
        visemeDriver.stop();
        microExpressionSystem.setSpeaking(false);
        resolve();
      };
      
      audio.onerror = (e) => {
        this.lipSyncDriver.stop();
        visemeDriver.stop();
        microExpressionSystem.setSpeaking(false);
        reject(e);
      };

      audio.play().catch((e) => {
        this.lipSyncDriver.stop();
        visemeDriver.stop();
        microExpressionSystem.setSpeaking(false);
        reject(e);
      });
    });
  }

  /**
   * æ£€æµ‹æ˜¯å¦åœ¨æœ¬åœ°ç¯å¢ƒ
   */
  private isLocalEnvironment(): boolean {
    const hostname = window.location.hostname;
    return hostname === 'localhost' || 
           hostname === '127.0.0.1' || 
           hostname.startsWith('192.168.') ||
           hostname.startsWith('10.') ||
           hostname.endsWith('.local');
  }

  /**
   * è¿æ¥ OpenClawï¼ˆè‡ªåŠ¨é€‰æ‹© Bridge æˆ– WebSocketï¼‰
   */
  async connect(): Promise<void> {
    const isLocal = this.isLocalEnvironment();
    
    // Bridge æ¨¡å¼ï¼ˆæœ¬åœ°ç›´è¿æˆ–å¤–ç½‘é€šè¿‡ä»£ç†ï¼‰
    if (this.useBridge) {
      console.log(`[AvatarSystem] ä½¿ç”¨ Bridge æ¨¡å¼è¿æ¥... (${isLocal ? 'æœ¬åœ°ç›´è¿' : 'ä»£ç†æ¨¡å¼'})`);
      console.log(`[AvatarSystem] Bridge URL: ${this.config.bridgeUrl}`);
      try {
        await this.bridgeConnector.connect();
        // è®¾ç½® Bridge æ¶ˆæ¯å¤„ç†
        this.bridgeConnector.onMessage((chunk) => {
          this.handleMessageChunk(chunk);
        });
        this.bridgeConnector.onStatusChange((status) => {
          this.updateState({ connectionStatus: status });
        });
        // ä¸»åŠ¨æ›´æ–°çŠ¶æ€ä¸ºå·²è¿æ¥
        this.updateState({ connectionStatus: 'connected' });
        console.log('[AvatarSystem] âœ… Bridge è¿æ¥æˆåŠŸï¼åˆéŸ³æœªæ¥å·²ä¸Šçº¿~');
        return;
      } catch (e) {
        console.warn('[AvatarSystem] Bridge è¿æ¥å¤±è´¥ï¼Œå°è¯• WebSocket:', e);
      }
    }
    
    // å›é€€åˆ° WebSocket
    console.log('[AvatarSystem] ä½¿ç”¨ WebSocket æ¨¡å¼è¿æ¥...');
    console.log(`[AvatarSystem] Gateway URL: ${this.config.gatewayUrl}`);
    
    await this.connector.connect();
  }

  /**
   * æ–­å¼€è¿æ¥
   */
  disconnect() {
    this.connector.disconnect();
    this.bridgeConnector.disconnect();
    this.ttsService?.stop();
    this.streamingTTSManager?.stop();
    this.isStreamingTTSStarted = false;
    this.lipSyncDriver.stop();
    this.ttsQueue = [];
    this.isProcessingTTS = false;
  }

  /**
   * å‘é€æ¶ˆæ¯
   */
  /**
   * å‘é€æ¶ˆæ¯ - ä¿®å¤ç‰ˆï¼ˆæ”¯æŒç‹¬ç«‹sessionï¼‰
   */
  async sendMessage(text: string): Promise<boolean> {
    // ğŸ¯ ä¿®å¤ï¼šä½¿ç”¨é…ç½®ä¸­çš„sessionKeyï¼Œç¡®ä¿ç‹¬ç«‹session
    const sessionKey = this.config.sessionKey || 'agent:main:avatar';
    
    console.log(`[AvatarSystem] å‘é€æ¶ˆæ¯åˆ°session: ${sessionKey}`);
    
    try {
      if (this.useBridge && this.bridgeConnector.getStatus() === 'connected') {
        return await this.bridgeConnector.sendMessage(text);
      }
      
      // ğŸ¯ å…³é”®ä¿®å¤ï¼šä¼ é€’sessionKeyå‚æ•°
      return await this.connector.sendMessage(text, { 
        sessionKey,
        thinkingLevel: 'low'  // Avatarä¸“ç”¨æ€ç»´çº§åˆ«
      });
    } catch (error) {
      console.error('[AvatarSystem] å‘é€æ¶ˆæ¯å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * ä¸­æ­¢å½“å‰å“åº”
   */
  async abort(): Promise<void> {
    await this.connector.abort();
    this.ttsQueue = [];
    this.isProcessingTTS = false;
    // åœæ­¢æµå¼ TTS
    this.streamingTTSManager?.stop();
    this.isStreamingTTSStarted = false;
    this.updateState({ isSpeaking: false, processingText: '' });
  }

  /**
   * è·å–èŠå¤©å†å²
   */
  async getHistory(): Promise<unknown[]> {
    return this.connector.getHistory();
  }

  /**
   * æ‰‹åŠ¨ TTS æ’­æ”¾ï¼ˆç”¨äºæµ‹è¯•ï¼‰
   */
  async speak(text: string): Promise<void> {
    if (!this.ttsService) {
      console.warn('[AvatarSystem] TTS æœªé…ç½®');
      // ä½¿ç”¨æ¨¡æ‹Ÿå£å‹
      await this.lipSyncDriver.simulateLipSync(text, text.length * 150);
      return;
    }

    this.updateState({ isSpeaking: true });
    
    try {
      // æ£€æµ‹æƒ…ç»ª
      if (this.config.enableEmotionDetection) {
        this.detectAndApplyEmotion(text);
      }

      const result = await this.ttsService.synthesize(text);
      await this.speakWithLipSync(text, result);
    } finally {
      this.updateState({ isSpeaking: false });
    }
  }

  /**
   * ä½¿ç”¨æµå¼ TTS æ’­æ”¾æ–‡æœ¬ (æ‰‹åŠ¨æµ‹è¯•ç”¨)
   * 
   * ç›¸æ¯”ä¼ ç»Ÿ speak()ï¼Œæµå¼ TTS ä¼šï¼š
   * 1. å°†æ–‡æœ¬æŒ‰å¥å­åˆ†å‰²
   * 2. å¹¶è¡Œåˆæˆå¤šä¸ªç‰‡æ®µ
   * 3. è¾¹åˆæˆè¾¹æ’­æ”¾ï¼Œä¸ç­‰å¾…å…¨éƒ¨å®Œæˆ
   * 4. æ˜¾è‘—é™ä½é¦–å­—å»¶è¿Ÿ
   */
  async speakStreaming(text: string): Promise<void> {
    if (!this.streamingTTSManager) {
      console.warn('[AvatarSystem] æµå¼ TTS æœªå¯ç”¨ï¼Œå›é€€åˆ°ä¼ ç»Ÿ TTS');
      return this.speak(text);
    }
    
    // æ£€æµ‹æƒ…ç»ª
    if (this.config.enableEmotionDetection) {
      this.detectAndApplyEmotion(text);
    }
    
    this.updateState({ isSpeaking: true });
    
    try {
      await this.streamingTTSManager.speak(text);
    } catch (e) {
      // æµå¼ TTS å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿ TTS
      console.warn('[AvatarSystem] æµå¼ TTS å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿ TTS:', e);
      try {
        await this.speak(text);
      } catch (e2) {
        // ä¼ ç»Ÿ TTS ä¹Ÿå¤±è´¥äº†ï¼Œå¿½ç•¥ï¼ˆå¯èƒ½æ˜¯æµ‹è¯•ç¯å¢ƒï¼‰
        console.warn('[AvatarSystem] ä¼ ç»Ÿ TTS ä¹Ÿå¤±è´¥:', e2);
      }
    } finally {
      this.updateState({ isSpeaking: false });
    }
  }
  
  /**
   * è·å–æµå¼ TTS çŠ¶æ€
   */
  getStreamingTTSState(): StreamingTTSState | null {
    return this.streamingTTSManager?.getState() ?? null;
  }
  
  /**
   * å¯ç”¨/ç¦ç”¨æµå¼ TTS
   */
  setUseStreamingTTS(enabled: boolean): void {
    this.updateConfig({ useStreamingTTS: enabled });
  }
  
  /**
   * æ£€æŸ¥æµå¼ TTS æ˜¯å¦å¯ç”¨
   */
  isStreamingTTSEnabled(): boolean {
    return this.config.useStreamingTTS && this.streamingTTSManager !== null;
  }

  /**
   * æ¨¡æ‹Ÿå¯¹è¯ï¼ˆç”¨äºæµ‹è¯•ï¼Œæ— éœ€ OpenClaw è¿æ¥ï¼‰
   */
  async simulateResponse(text: string): Promise<void> {
    // æ£€æµ‹æƒ…ç»ª
    if (this.config.enableEmotionDetection) {
      this.detectAndApplyEmotion(text);
    }

    // æ›´æ–°çŠ¶æ€
    this.updateState({
      lastMessage: text,
      processingText: '',
    });

    // é€šçŸ¥æ–‡æœ¬å›è°ƒ
    this.notifyTextCallbacks(text, true);

    // ä½¿ç”¨æµå¼ TTSï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (this.config.useStreamingTTS && this.streamingTTSManager) {
      await this.speakStreaming(text);
    } else {
      await this.speak(text);
    }
  }

  /**
   * è®¢é˜…çŠ¶æ€å˜åŒ–
   */
  onStateChange(callback: StateChangeCallback): () => void {
    this.stateCallbacks.add(callback);
    // ç«‹å³å‘é€å½“å‰çŠ¶æ€
    callback(this.state);
    return () => this.stateCallbacks.delete(callback);
  }

  /**
   * è®¢é˜…æ–‡æœ¬æ›´æ–°
   */
  onText(callback: TextCallback): () => void {
    this.textCallbacks.add(callback);
    return () => this.textCallbacks.delete(callback);
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getState(): SystemState {
    return { ...this.state };
  }

  /**
   * æ›´æ–°çŠ¶æ€
   */
  private updateState(partial: Partial<SystemState>) {
    this.state = { ...this.state, ...partial };
    
    for (const callback of this.stateCallbacks) {
      try {
        callback(this.state);
      } catch (e) {
        console.error('[AvatarSystem] çŠ¶æ€å›è°ƒé”™è¯¯:', e);
      }
    }
  }

  /**
   * é€šçŸ¥æ–‡æœ¬å›è°ƒ
   */
  private notifyTextCallbacks(text: string, isComplete: boolean) {
    for (const callback of this.textCallbacks) {
      try {
        callback(text, isComplete);
      } catch (e) {
        console.error('[AvatarSystem] æ–‡æœ¬å›è°ƒé”™è¯¯:', e);
      }
    }
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig(config: Partial<AvatarSystemConfig>) {
    if (config.fishApiKey && config.fishApiKey !== this.config.fishApiKey) {
      this.ttsService = createTTSService(config.fishApiKey);
      // åŒæ—¶æ›´æ–°æµå¼ TTS ç®¡ç†å™¨çš„ API Key
      this.streamingTTSManager?.updateConfig({ apiKey: config.fishApiKey });
      console.log('[AvatarSystem] TTS æœåŠ¡å·²æ›´æ–°');
    }
    
    // æ›´æ–°æµå¼ TTS å¼€å…³
    if (config.useStreamingTTS !== undefined && config.useStreamingTTS !== this.config.useStreamingTTS) {
      this.config.useStreamingTTS = config.useStreamingTTS;
      if (config.useStreamingTTS && !this.streamingTTSManager) {
        this.streamingTTSManager = createStreamingTTSManager({
          apiKey: this.config.fishApiKey || 'ceea7f5420dc4214807f4ce5dccb9da3',
          referenceId: '9dec9671824543b4a4f9f382dbf15748',
        });
        this.setupStreamingTTSCallbacks();
      }
      console.log('[AvatarSystem] æµå¼ TTS:', config.useStreamingTTS ? 'å¯ç”¨' : 'ç¦ç”¨');
    }
    
    // æ›´æ–°è¿æ¥å™¨é…ç½®
    const connectorUpdates: { token?: string; gatewayUrl?: string } = {};
    
    if (config.gatewayToken !== undefined) {
      connectorUpdates.token = config.gatewayToken;
    }
    
    if (config.gatewayUrl) {
      connectorUpdates.gatewayUrl = config.gatewayUrl;
    }
    
    if (Object.keys(connectorUpdates).length > 0) {
      this.connector.updateConfig(connectorUpdates);
      console.log('[AvatarSystem] è¿æ¥å™¨é…ç½®å·²æ›´æ–°:', Object.keys(connectorUpdates));
    }
    
    this.config = { ...this.config, ...config };
  }

  /**
   * è®¾ç½® Gateway Token (ä¾¿æ·æ–¹æ³•)
   */
  setGatewayToken(token: string) {
    this.config.gatewayToken = token;
    this.connector.setToken(token);
  }

  // ========== è¡¨æƒ…åºåˆ—ç³»ç»Ÿ API ==========

  /**
   * å¯ç”¨/ç¦ç”¨è¡¨æƒ…åºåˆ—ç³»ç»Ÿ
   */
  setUseSequencer(enabled: boolean) {
    this.useSequencer = enabled;
    console.log('[AvatarSystem] è¡¨æƒ…åºåˆ—ç³»ç»Ÿ:', enabled ? 'å¯ç”¨' : 'ç¦ç”¨');
  }

  /**
   * æ’­æ”¾é¢„å®šä¹‰çš„è¡¨æƒ…åºåˆ—
   */
  playSequence(name: string): boolean {
    return expressionSequencer.playPreset(name as any);
  }

  /**
   * è·å–å¯ç”¨çš„è¡¨æƒ…åºåˆ—åˆ—è¡¨
   */
  getAvailableSequences(): string[] {
    return expressionSequencer.getPresetNames();
  }

  /**
   * åœæ­¢å½“å‰è¡¨æƒ…åºåˆ—
   */
  stopSequence() {
    expressionSequencer.stop();
  }

  /**
   * è·å–è¡¨æƒ…åºåˆ—ç³»ç»ŸçŠ¶æ€
   */
  getSequencerState() {
    return {
      isPlaying: expressionSequencer.isSequencePlaying(),
      currentSequence: expressionSequencer.getCurrentSequenceName(),
      emotionState: expressionSequencer.getEmotionState(),
      emotionHistory: expressionSequencer.getEmotionHistory(),
    };
  }

  // ========== å¤´éƒ¨è¿½è¸ª API ==========

  /**
   * æ£€æŸ¥å¤´éƒ¨è¿½è¸ªæ˜¯å¦æ”¯æŒ
   */
  async checkHeadTrackingSupport(): Promise<boolean> {
    const supported = await headTrackingService.constructor.isSupported?.() ?? 
      !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    this.updateState({ headTrackingSupported: supported });
    return supported;
  }

  /**
   * å¯åŠ¨å¤´éƒ¨è¿½è¸ª
   */
  async startHeadTracking(): Promise<void> {
    try {
      // åˆå§‹åŒ–æœåŠ¡
      await headTrackingService.init();
      
      // è®¢é˜…è¿½è¸ªæ•°æ®
      this.headTrackingUnsubscribe = headTrackingService.onTracking((data: TrackingData) => {
        this.handleHeadTrackingData(data);
      });
      
      // å¯åŠ¨è¿½è¸ª
      await headTrackingService.start();
      
      this.updateState({ isHeadTrackingActive: true });
      console.log('[AvatarSystem] âœ… å¤´éƒ¨è¿½è¸ªå·²å¯åŠ¨');
    } catch (err) {
      console.error('[AvatarSystem] å¤´éƒ¨è¿½è¸ªå¯åŠ¨å¤±è´¥:', err);
      throw err;
    }
  }

  /**
   * åœæ­¢å¤´éƒ¨è¿½è¸ª
   */
  stopHeadTracking(): void {
    if (this.headTrackingUnsubscribe) {
      this.headTrackingUnsubscribe();
      this.headTrackingUnsubscribe = null;
    }
    
    headTrackingService.stop();
    this.updateState({ isHeadTrackingActive: false });
    console.log('[AvatarSystem] å¤´éƒ¨è¿½è¸ªå·²åœæ­¢');
  }

  /**
   * å¤„ç†å¤´éƒ¨è¿½è¸ªæ•°æ®
   */
  private handleHeadTrackingData(data: TrackingData): void {
    // æ›´æ–° Avatar è§†çº¿ä½ç½®
    const screenX = (data.pose.x + 1) / 2;  // è½¬æ¢åˆ° 0-1
    const screenY = (data.pose.y + 1) / 2;
    avatarController.lookAt(screenX, screenY);
    
    // å¯é€‰: æ ¹æ®ç”¨æˆ·è¡¨æƒ…åŒæ­¥ Avatar è¡¨æƒ…
    if (data.expression.detectedEmotion && data.expression.detectedEmotion !== 'neutral') {
      // ç”¨æˆ·å¾®ç¬‘æ—¶ï¼ŒAvatar ä¹Ÿå¾®ç¬‘
      if (data.expression.mouthSmile > 0.5 && this.state.currentEmotion === 'neutral') {
        this.setEmotion('happy');
      }
    }
    
    // æ ¹æ®çœ¼ç›çŠ¶æ€è§¦å‘çœ¨çœ¼
    if (data.expression.leftEyeOpen < 0.2 && data.expression.rightEyeOpen < 0.2) {
      avatarController.triggerBlink?.();
    }
  }

  /**
   * è·å–å¤´éƒ¨è¿½è¸ªçŠ¶æ€
   */
  getHeadTrackingStatus(): { active: boolean; supported: boolean } {
    return {
      active: this.state.isHeadTrackingActive,
      supported: this.state.headTrackingSupported,
    };
  }

  // ========== é”®ç›˜å¿«æ·é”® API ==========

  /**
   * åˆå§‹åŒ–é”®ç›˜å¿«æ·é”®
   */
  initKeyboardShortcuts(callbacks: {
    onToggleChat?: () => void;
    onToggleSettings?: () => void;
    onToggleVoice?: () => void;
    onToggleTracking?: () => void;
    onExpressionChange?: (emotion: Expression) => void;
    onFocusInput?: () => void;
    onSendMessage?: () => void;
    onClearChat?: () => void;
    onToggleTheme?: () => void;
    onToggleFullscreen?: () => void;
    onEscape?: () => void;
    onHelp?: () => void;
  }): void {
    keyboardShortcuts.init();
    
    keyboardShortcuts.registerDefaults({
      'toggle-chat': callbacks.onToggleChat,
      'toggle-settings': callbacks.onToggleSettings,
      'toggle-voice': callbacks.onToggleVoice,
      'toggle-tracking': callbacks.onToggleTracking ?? (() => {
        if (this.state.isHeadTrackingActive) {
          this.stopHeadTracking();
        } else {
          this.startHeadTracking().catch(console.error);
        }
      }),
      'expression-happy': () => callbacks.onExpressionChange?.('happy') ?? this.setEmotion('happy'),
      'expression-sad': () => callbacks.onExpressionChange?.('sad') ?? this.setEmotion('sad'),
      'expression-surprised': () => callbacks.onExpressionChange?.('surprised') ?? this.setEmotion('surprised'),
      'expression-neutral': () => callbacks.onExpressionChange?.('neutral') ?? this.setEmotion('neutral'),
      'focus-input': callbacks.onFocusInput,
      'send-message': callbacks.onSendMessage,
      'clear-chat': callbacks.onClearChat,
      'toggle-theme': callbacks.onToggleTheme,
      'toggle-fullscreen': callbacks.onToggleFullscreen ?? (() => {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          document.documentElement.requestFullscreen();
        }
      }),
      'escape': callbacks.onEscape,
      'help': callbacks.onHelp,
    });
    
    console.log('[AvatarSystem] âœ… é”®ç›˜å¿«æ·é”®å·²åˆå§‹åŒ–');
  }

  /**
   * è·å–æ‰€æœ‰å¿«æ·é”®
   */
  getKeyboardShortcuts() {
    return keyboardShortcuts.getAll();
  }

  /**
   * æ ¼å¼åŒ–å¿«æ·é”®æ˜¾ç¤º
   */
  formatShortcut(keys: string[]): string {
    return formatShortcut(keys);
  }

  // ========== æ‰‹åŠ¿è¯†åˆ« API ==========

  /**
   * å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
   */
  async startGestureRecognition(): Promise<void> {
    try {
      // åˆå§‹åŒ–å¹¶å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
      const success = await gestureRecognitionService.start();
      
      if (!success) {
        throw new Error('æ‰‹åŠ¿è¯†åˆ«å¯åŠ¨å¤±è´¥');
      }
      
      // è®¢é˜…æ‰‹åŠ¿äº‹ä»¶
      this.gestureRecognitionUnsubscribe = gestureRecognitionService.onGesture((result: GestureResult) => {
        this.handleGestureResult(result);
      });
      
      // è®¢é˜…ååº”äº‹ä»¶
      this.gestureReactionUnsubscribe = gestureReactionMapper.onReaction((gesture, reaction, message) => {
        this.updateState({
          lastGesture: gesture,
          lastGestureMessage: message || null,
        });
      });
      
      this.updateState({ isGestureRecognitionActive: true });
      console.log('[AvatarSystem] âœ… æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨');
    } catch (err) {
      console.error('[AvatarSystem] æ‰‹åŠ¿è¯†åˆ«å¯åŠ¨å¤±è´¥:', err);
      throw err;
    }
  }

  /**
   * åœæ­¢æ‰‹åŠ¿è¯†åˆ«
   */
  stopGestureRecognition(): void {
    if (this.gestureRecognitionUnsubscribe) {
      this.gestureRecognitionUnsubscribe();
      this.gestureRecognitionUnsubscribe = null;
    }
    
    if (this.gestureReactionUnsubscribe) {
      this.gestureReactionUnsubscribe();
      this.gestureReactionUnsubscribe = null;
    }
    
    gestureRecognitionService.stop();
    this.updateState({ 
      isGestureRecognitionActive: false,
      lastGesture: null,
      lastGestureMessage: null,
    });
    console.log('[AvatarSystem] æ‰‹åŠ¿è¯†åˆ«å·²åœæ­¢');
  }

  /**
   * å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
   */
  private handleGestureResult(result: GestureResult): void {
    // ä½¿ç”¨ GestureReactionMapper å¤„ç†æ‰‹åŠ¿
    gestureReactionMapper.react(result.gesture);
    
    console.log('[AvatarSystem] æ£€æµ‹åˆ°æ‰‹åŠ¿:', result.gesture, 'ç½®ä¿¡åº¦:', result.confidence);
  }

  /**
   * è·å–æ‰‹åŠ¿è¯†åˆ«çŠ¶æ€
   */
  getGestureRecognitionStatus(): { 
    active: boolean; 
    lastGesture: string | null;
    lastMessage: string | null;
  } {
    return {
      active: this.state.isGestureRecognitionActive,
      lastGesture: this.state.lastGesture,
      lastMessage: this.state.lastGestureMessage,
    };
  }

  /**
   * è®¾ç½®æ‰‹åŠ¿ååº”å¯ç”¨çŠ¶æ€
   */
  setGestureReactionEnabled(enabled: boolean): void {
    gestureReactionMapper.setEnabled(enabled);
  }

  /**
   * è‡ªå®šä¹‰æ‰‹åŠ¿ååº”
   */
  setGestureReaction(gesture: string, reaction: GestureReaction): void {
    gestureReactionMapper.setReaction(gesture as any, reaction);
  }

  /**
   * é”€æ¯
   */
  destroy() {
    this.disconnect();
    this.ttsService?.destroy();
    this.streamingTTSManager?.destroy();
    this.lipSyncDriver.destroy();
    expressionSequencer.destroy();
    
    // åœæ­¢å¤´éƒ¨è¿½è¸ª
    this.stopHeadTracking();
    headTrackingService.destroy();
    
    // åœæ­¢æ‰‹åŠ¿è¯†åˆ«
    this.stopGestureRecognition();
    gestureRecognitionService.destroy();
    gestureReactionMapper.destroy();

    // æ¸…ç†è§¦æ‘¸äº’åŠ¨
    if (this.touchReactionUnsubscribe) this.touchReactionUnsubscribe();
    if (this.touchAffectionUnsubscribe) this.touchAffectionUnsubscribe();
    if (this.touchExcessiveUnsubscribe) this.touchExcessiveUnsubscribe();
    this.touchInteraction.destroy();
    this.touchParticleCallbacks.clear();
    
    // é”€æ¯é”®ç›˜å¿«æ·é”®
    keyboardShortcuts.destroy();
    
    if (this.emotionResetTimer) {
      clearTimeout(this.emotionResetTimer);
    }
    
    this.stateCallbacks.clear();
    this.textCallbacks.clear();
  }
}

// å…¨å±€å®ä¾‹
export const avatarSystem = new AvatarSystem();
